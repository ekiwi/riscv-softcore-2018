      // Quiz, what does 60 mean in this context?      // Answer: A3P060 :)            //      //      //            #file 2      #line 1      // Microcode Mnemonics for RISC-V             var ZERO: byte @R0;      var FF: byte @R1;            var ECAUSE: byte @R9;      var PC: word @R10;      var oldPC: word @R12;            // Instruction word      var I0: byte @R16;      var I1: byte @R17;      var I2: byte @R18;      var I3: byte @R19;            // Destination work area      var RD0: byte @R20;      var RD1: byte @R21;      var RD2: byte @R22;      var RD3: byte @R23;            var RS2_0: byte @R24;      var RS2_1: byte @R25;      var RS2_2: byte @R26;      var RS2_3: byte @R27;            var TEMP: byte @R28;      // 29 is WREG      var Z: word @W30;      var Zlo: byte @R30;      var Zhi: byte @R31;                  var RS1_0: byte @R12;      var RS1_1: byte @R13;      var RS1_2: byte @R14;      var RS1_3: byte @R15;                        const RRH = $F1;      const CRH = $F2;                                          	            #file 1      #line 9            #file 3      #line 1      const UART_BAUDCONST = 77;  // 115200 @27MHz            Const SPI_ADDR3 = $02                  #file 1      #line 11      //#include brd_sf2.inc      //#include brd_s7m.inc            //      // Start here      //      	WREG := 0; ZERO := WREG; // simulator friendly version, can save 2 bytes in FPGA !0000:E0F0 LDI R31,0x000001:2E0F MOV R0,R31      	WREG := $FF0002:EFFF LDI R31,0xFF      	FF   := WREG;0003:2E1F MOV R1,R31            #file 4      #line 1            	RD3 := ZERO;         // for verilator and simulation0004:2D70 MOV R23,R0            	SPI_CS  := FF;0005:B818 OUT SPI_CS,R1      	SPI_SCK := ZERO;0006:BA00 OUT SPI_SCK,R0            ////////////////////      	SPI_CS  := ZERO0007:B808 OUT SPI_CS,R0      	RD0 := $AB; // wakeup !0008:EA4B LDI R20,0xAB      		wreg := 00009:E0F0 LDI R31,0x00      		repeat      			SPI_MOSI := RD0;000A:BB48 OUT SPI_MOSI,R20      				SPI_SCK := FF;000B:BA10 OUT SPI_SCK,R1      			ADD RD0, RD0000C:0F44 ADD R20,R20              			SPI_SCK := ZERO;000D:BA00 OUT SPI_SCK,R0      			//inc wreg;      			SUB WREG,FF000E:19F1 SUB R31,R1      		until wreg.3;000F:FFF3 SBRS R31,30010:CFF9 RJMP 0x000A      	SPI_CS  := FF0011:B818 OUT SPI_CS,R1      ////////////////////            	RD0 := $03;  // first byte0012:E043 LDI R20,0x03      	RD1 := SPI_ADDR3;  //second byte to transmit0013:E052 LDI R21,0x02            	SPI_CS  := ZERO0014:B808 OUT SPI_CS,R0      	// we start at fake high address so we are at 0 when we get first byte      	Z.lo := $FC; 0015:EFEC LDI R30,0xFC      	Z.hi := $FF;0016:EFFF LDI R31,0xFF            bootloop:      		wreg := 00017:E0F0 LDI R31,0x00      		repeat      			RD2 := SPI_MISO; // Get SPI data0018:B368 IN R22,SPI_MOSI      			AND RD2, 1;      // only one 1 bit0019:7061 ANDI R22,0x01      			ADD RD3, RD3001A:0F77 ADD R23,R23      			OR RD3, RD2	001B:2B76 OR  R23,R22      			SPI_MOSI := RD0;001C:BB48 OUT SPI_MOSI,R20      				SPI_SCK := FF;001D:BA10 OUT SPI_SCK,R1      			ADD RD1, RD1001E:0F55 ADD R21,R21      			ADC RD0, RD0001F:1F44 ADC R20,R20              			SPI_SCK := ZERO;0020:BA00 OUT SPI_SCK,R0      			//inc wreg;      			SUB WREG,FF			0021:19F1 SUB R31,R1      		until wreg.3;0022:FFF3 SBRS R31,30023:CFF4 RJMP 0x0018            		RAM[Z] := RD3;0024:8370 ST Z,R23      		ADD Z.lo, 10025:5FEF SUBI R30,0xFF      		SBC Z.hi, FF0026:09F1 SBC R31,R1      	if Zhi.6 then bootloop0027:FDF6 SBRC R31,60028:CFEE RJMP 0x0017      	if not Zhi.7 then bootloop0029:FFF7 SBRS R31,7002A:CFEC RJMP 0x0017            	SPI_CS  := FF;002B:B818 OUT SPI_CS,R1            #file 1      #line 22            //#include ramclear.inc      //#include raminit.inc	            	PC.lo := ZERO;002C:2CA0 MOV R10,R0      	PC.hi := ZERO;002D:2CB0 MOV R11,R0            //======================================      //      // Main Loop      //	            	goto MainStart002E:C027 RJMP 0x0056      MISALIGN_LD:      	WREG := 4002F:E0F4 LDI R31,0x04      	goto misaling_ldst0030:C001 RJMP 0x0032      MISALIGN_ST:      	WREG := 60031:E0F6 LDI R31,0x06      misaling_ldst:      	oldPC := PC0032:2CCA MOV R12,R100033:2CDB MOV R13,R11      	PC.lo := Z.lo 0034:2EAE MOV R10,R30      	PC.hi := Z.hi0035:2EBF MOV R11,R31      	goto mtvec_mtval0036:C014 RJMP 0x004B            Store_0:      	RD0 := 0;0037:E040 LDI R20,0x00      Store_RD_BYTE:      	RD1 := 0;0038:E050 LDI R21,0x00      Store_RD_WORD:      	RD2 := 0;0039:E060 LDI R22,0x00      	RD3 := 0;003A:E070 LDI R23,0x00            Store_RD:            // xxxx_xxxx xxxx_xxxx xxxx_4321 0xxx_xxxx      // x432 10xx      //  	Z.lo := I1      //	swap Z.lo      //	lsr Z.lo      //	and Z.lo, $78      //	if not I0.7 then skip; Z.lo := Z.lo or $04;              	Z.lo := I1003B:2FE1 MOV R30,R17      	swap Z.lo003C:95E2 SWAP R30      	//lsr Z.lo      	and Z.lo, $F0003D:7FE0 ANDI R30,0xF0      	if not I0.7 then skip; Z.lo := Z.lo or $08;003E:FD07 SBRC R16,7003F:60E8 ORI R30,0x08                  	// rd = 0? If so do not store it!      	if Z.lo = $00 then MainLoop0040:23EE AND R30,R300041:F029 BREQ 0x0047      	// Store RD to r1..r31      	Z.Hi := RRH; // Register save area0042:EFF1 LDI R31,0xF1      	RAM[Z] := RD0; 0043:8340 ST Z,R20      	RAM[Z+1] := RD1;0044:8351 ST Z+1,R21      	RAM[Z+2] := RD2;0045:8362 ST Z+2,R22      	RAM[Z+3] := RD3; 0046:8373 ST Z+3,R23            	repeat      MainLoop:      //      // Fetch new instruction word into I0..I3      //              WREG := PC.lo0047:2DFA MOV R31,R10      	if not WREG.1 then NextPC0048:FFF1 SBRS R31,10049:C009 RJMP 0x0053      // Misaligned jump!      	WREG := 0; // Misaligned jump004A:E0F0 LDI R31,0x00      mtvec_mtval:      	Z.hi  := CRH004B:EFF2 LDI R31,0xF2      	// store mtval      	Z.lo := $30004C:E3E0 LDI R30,0x30      	RAM[Z] := PC.lo; //004D:82A0 ST Z,R10      	RAM[Z+1] := PC.hi004E:82B1 ST Z+1,R11      mtvec_mepc:      	// store mepc      	Z.lo := $10004F:E1E0 LDI R30,0x10      	RAM[Z] := oldPC.lo; //0050:82C0 ST Z,R12      	RAM[Z+1] := oldPC.hi0051:82D1 ST Z+1,R13      mtvec_ecause:      	goto go_mtvec_ecause0052:C0CF RJMP 0x0122      //      NextPC:              //PC := PC+4;              PC.lo := PC.lo+4;0053:E0F4 LDI R31,0x040054:0EAF ADD R10,R31      	ADC PC.hi, ZERO0055:1CB0 ADC R11,R0            MainStart:      //      // Thread switching should appear here for hardware multithreaded support      //            	oldPC := PC0056:2CCA MOV R12,R100057:2CDB MOV R13,R11      	Z := PC;0058:2DEA MOV R30,R100059:2DFB MOV R31,R11                        	I0 := RAM[Z];005A:8100 LD R16,Z       	I1 := RAM[Z+1];005B:8111 LD R17,Z+1      	I2 := RAM[Z+2]; 005C:8122 LD R18,Z+2      	I3 := RAM[Z+3];005D:8133 LD R19,Z+3            //      // Start instruction decoding and emulation      //             if I0.2 then goto I_XX_XX1005E:FD02 SBRC R16,2005F:C172 RJMP 0x01D2      //      // need load rs1      //            // xxxx_xxxx xxxx_xxxx xxxx_4321 0xxx_xxxx      // x432 10xx            LD_rs1:      //        Z.lo := I2      //	swap Z.lo      //	lsr Z.lo      //	Z.lo := Z.lo and $78      //	if not I1.7 then skip; Z.lo := Z.lo or $04;                    Z.lo := I20060:2FE2 MOV R30,R18      	swap Z.lo0061:95E2 SWAP R30      	//lsr Z.lo      	Z.lo := Z.lo and $F00062:7FE0 ANDI R30,0xF0      	if not I1.7 then skip; Z.lo := Z.lo or $08;0063:FD17 SBRC R17,70064:60E8 ORI R30,0x08            //      	Z.Hi := RRH; // Register save area0065:EFF1 LDI R31,0xF1      	RS1_0 := RAM[Z]; 0066:80C0 LD R12,Z       	RS1_1 := RAM[Z+1]; 0067:80D1 LD R13,Z+1      	RS1_2 := RAM[Z+2];0068:80E2 LD R14,Z+2      	RS1_3 := RAM[Z+3]; 0069:80F3 LD R15,Z+3                    if I0.5 then goto I_X1_XX0006A:FD05 SBRC R16,5006B:C097 RJMP 0x0103      //      I_0X_XX0:      I_XX_XX0:      I_IMMED:      // Get immed 11:0 and sign extend	      	RD3 := $FF; // 006C:EF7F LDI R23,0xFF      	RD2 := $FF; // 006D:EF6F LDI R22,0xFF      	RD0 := I2; SWAP RD0; RD0 := RD0 and $0F;006E:2F42 MOV R20,R18006F:9542 SWAP R200070:704F ANDI R20,0x0F      	SWAP I3;0071:9532 SWAP R19      	RD1 := I3;          RD1 := RD1 or $F0;0072:2F53 MOV R21,R190073:6F50 ORI R21,0xF0      	I3 := I3 and $F0;   RD0 := RD0 or I3;0074:7F30 ANDI R19,0xF00075:2B43 OR  R20,R19      	if RD1.3 then goto imm12_p0076:FD53 SBRC R21,30077:C003 RJMP 0x007B      	RD1 := RD1 and $0F;0078:705F ANDI R21,0x0F      	RD2 := 0;0079:E060 LDI R22,0x00      	RD3 := 0; 007A:E070 LDI R23,0x00      imm12_p:        // 12 bit immed in RD	              if not I0.4 then goto I_00_0X1 // JALR >>007B:FF04 SBRS R16,4007C:C054 RJMP 0x00D1            // IMM ALU              if I1.6 then goto LOGIC007D:FD16 SBRC R17,6007E:C009 RJMP 0x0088      // 0XX              if I1.5 then goto DO_SLT007F:FD15 SBRC R17,50080:C043 RJMP 0x00C4      // 00X              if I1.4 then goto DO_SLLI0081:FD14 SBRC R17,40082:C01B RJMP 0x009E      // 000      // ADDI      // 32 bit ADD      Do_ADDI:              RD0 := RD0 + RS1_00083:0D4C ADD R20,R12              ADC RD1, RS1_10084:1D5D ADC R21,R13              ADC RD2, RS1_20085:1D6E ADC R22,R14              ADC RD3, RS1_30086:1D7F ADC R23,R15      	goto Store_RD0087:CFB3 RJMP 0x003B            LOGIC:              if I1.5 then goto OR_AND0088:FD15 SBRC R17,50089:C007 RJMP 0x0091              if I1.4 then goto Do_SR008A:FD14 SBRC R17,4008B:C026 RJMP 0x00B2      Do_XOR:              RD0 := RD0 xor RS1_0008C:254C EOR R20,R12              RD1 := RD1 xor RS1_1008D:255D EOR R21,R13              RD2 := RD2 xor RS1_2008E:256E EOR R22,R14              RD3 := RD3 xor RS1_3008F:257F EOR R23,R15      	goto Store_RD0090:CFAA RJMP 0x003B            OR_AND:              if I1.4 then goto DO_AND0091:FD14 SBRC R17,40092:C005 RJMP 0x0098      Do_OR:              RD0 := RD0 or RS1_00093:294C OR  R20,R12              RD1 := RD1 or RS1_10094:295D OR  R21,R13              RD2 := RD2 or RS1_20095:296E OR  R22,R14              RD3 := RD3 or RS1_30096:297F OR  R23,R15      	goto Store_RD0097:CFA3 RJMP 0x003B      Do_AND:              RD0 := RD0 and RS1_00098:214C AND R20,R12              RD1 := RD1 and RS1_10099:215D AND R21,R13              RD2 := RD2 and RS1_2009A:216E AND R22,R14              RD3 := RD3 and RS1_3009B:217F AND R23,R15      	goto Store_RD009C:CF9E RJMP 0x003B            Do_SLL:      	RD0 := RS2_0009D:2F48 MOV R20,R24      //	Goto Do_SLLI	      DO_SLLI:      	RD0 := RD0 and $1F;009E:714F ANDI R20,0x1F      asm      	breq Store_RS1009F:F031 BREQ 0x00A6      end      	repeat      		ADD RS1_0, RS1_000A0:0CCC ADD R12,R12      		ADC RS1_1, RS1_100A1:1CDD ADC R13,R13      		ADC RS1_2, RS1_200A2:1CEE ADC R14,R14      		ADC RS1_3, RS1_300A3:1CFF ADC R15,R15            		ADD RD0,FF00A4:0D41 ADD R20,R1      	until FLAGS.100A5:F7D1 BRNE 0x00A0      //	until --RD0;            Store_RS1:      	RD0 := RS1_0;00A6:2D4C MOV R20,R12      	RD1 := RS1_1;00A7:2D5D MOV R21,R13      	RD2 := RS1_2;00A8:2D6E MOV R22,R14      	RD3 := RS1_3;00A9:2D7F MOV R23,R15      	goto Store_RD00AA:CF90 RJMP 0x003B            Do_XOR_AND:      	if I1.5 then goto OR_AND // bit 00AB:FD15 SBRC R17,500AC:CFE4 RJMP 0x0091      	if not I1.4 then goto Do_XOR // bit 00AD:FF14 SBRS R17,400AE:CFDD RJMP 0x008C      // SRL SRA      	RD0 := RS2_000AF:2F48 MOV R20,R24      	RD1 := I300B0:2F53 MOV R21,R19      	swap RD100B1:9552 SWAP R21      //	goto Do_SR            //      // SRLI, SRAI      //      Do_SR:      	RD0 := RD0 and $1F;00B2:714F ANDI R20,0x1F      asm      	breq Store_RS100B3:F391 BREQ 0x00A6      end            // SRLI/SRAI?      	// I3.6 > RD1.3 !      	if not RD1.2 then goto DO_SRLI00B4:FF52 SBRS R21,200B5:C007 RJMP 0x00BD      // SRAI      	repeat      		ASR RS1_300B6:94F5 ASR R15      		ROR RS1_200B7:94E7 ROR R14      		ROR RS1_100B8:94D7 ROR R13      		ROR RS1_000B9:94C7 ROR R12      		ADD RD0,FF00BA:0D41 ADD R20,R1      	until FLAGS.100BB:F7D1 BRNE 0x00B6      //	until --RD0;            	goto Store_RS100BC:CFE9 RJMP 0x00A6            //      Do_SRLI:      	repeat      		LSR RS1_300BD:94F6 LSR R15      		ROR RS1_200BE:94E7 ROR R14      		ROR RS1_100BF:94D7 ROR R13      		ROR RS1_000C0:94C7 ROR R12      		ADD RD0,FF00C1:0D41 ADD R20,R1      	until FLAGS.100C2:F7D1 BRNE 0x00BD      //	until --RD0;            	goto Store_RS100C3:CFE2 RJMP 0x00A6                  //      // SLTI, SLTIU      //      DO_SLT:      	if I1.4 then goto Do_SLTIU00C4:FD14 SBRC R17,400C5:C003 RJMP 0x00C9      	WREG := $80;	00C6:E8F0 LDI R31,0x80      	RS1_3 := RS1_3 + WREG00C7:0EFF ADD R15,R31      	RD3 := RD3 + WREG00C8:0F7F ADD R23,R31      Do_SLTIU:              SUB RS1_0, RD000C9:1AC4 SUB R12,R20              SBC RS1_1, RD100CA:0AD5 SBC R13,R21              SBC RS1_2, RD200CB:0AE6 SBC R14,R22              SBC RS1_3, RD300CC:0AF7 SBC R15,R23      asm      	brcs Store_100CD:F008 BRCS 0x00CF      end            	goto Store_000CE:CF68 RJMP 0x0037      Store_1:      	RD0 := 1;00CF:E041 LDI R20,0x01      	goto Store_RD_BYTE00D0:CF67 RJMP 0x0038                  // LOAD      // RS1 loaded, RD immed      I_00_0X1:      	//      	if not I0.6 then goto Do_Loads00D1:FF06 SBRS R16,600D2:C00F RJMP 0x00E2            // JALR      	ADD RS1_0, RD000D3:0EC4 ADD R12,R20      	ADC RS1_1, RD100D4:1ED5 ADC R13,R21            	//PC := PC+4      	PC.lo := PC.lo+400D5:E0F4 LDI R31,0x0400D6:0EAF ADD R10,R31      	ADC PC.hi, ZERO00D7:1CB0 ADC R11,R0            	RD0 := PC.lo00D8:2D4A MOV R20,R10      	RD1 := PC.hi00D9:2D5B MOV R21,R11            	AND RS1_0, $FE	// JALR TEST !00DA:EFFE LDI R31,0xFE00DB:22CF AND R12,R31      	      	PC.lo := RS1_000DC:2CAC MOV R10,R12      	PC.hi := RS1_100DD:2CBD MOV R11,R13            	WREG := 400DE:E0F4 LDI R31,0x04      	SUB PC.lo, WREG00DF:1AAF SUB R10,R31      	SBC PC.hi, ZERO00E0:08B0 SBC R11,R0            	// Store return PC      	goto Store_RD_WORD00E1:CF57 RJMP 0x0039                  Do_LOADS:      	Z.Lo := RS1_0;00E2:2DEC MOV R30,R12      	Z.Hi := RS1_1;00E3:2DFD MOV R31,R13      	Z.Lo := Z.lo + RD000E4:0FE4 ADD R30,R20      	ADC Z.Hi, RD100E5:1FF5 ADC R31,R21      // Load from memory      	RD0 := RAM[Z];00E6:8140 LD R20,Z               if I1.4 then goto I_LD_H // 00E7:FD14 SBRC R17,400E8:C014 RJMP 0x00FD              if I1.5 then goto I_LD_W // 00E9:FD15 SBRC R17,500EA:C00A RJMP 0x00F5      // LB, LBU      	if I1.6 then goto Store_RD_BYTE00EB:FD16 SBRC R17,600EC:CF4B RJMP 0x0038      	if not RD0.7 then goto Store_RD_BYTE00ED:FF47 SBRS R20,700EE:CF49 RJMP 0x0038      	RD1 := $FF00EF:EF5F LDI R21,0xFF      //	goto I_LH      I_LH:      // sign extend      	if not RD1.7 then goto Store_RD_WORD00F0:FF57 SBRS R21,700F1:CF47 RJMP 0x0039      	RD2 := $FF;00F2:EF6F LDI R22,0xFF      	RD3 := $FF;00F3:EF7F LDI R23,0xFF      	goto Store_RD00F4:CF46 RJMP 0x003B            I_LD_W:      	if Zlo.0 then MISALIGN_LD00F5:FDE0 SBRC R30,000F6:CF38 RJMP 0x002F      	if Zlo.1 then MISALIGN_LD00F7:FDE1 SBRC R30,100F8:CF36 RJMP 0x002F            	RD1 := RAM[Z+1]; 00F9:8151 LD R21,Z+1      	RD2 := RAM[Z+2]; 00FA:8162 LD R22,Z+2      	RD3 := RAM[Z+3];00FB:8173 LD R23,Z+3      	goto Store_RD	00FC:CF3E RJMP 0x003B      //            I_LD_H:      	if Zlo.0 then MISALIGN_LD00FD:FDE0 SBRC R30,000FE:CF30 RJMP 0x002F            	RD1 := RAM[Z+1]; 00FF:8151 LD R21,Z+1      	if not I1.6 then goto I_LH // 0100:FF16 SBRS R17,60101:CFEE RJMP 0x00F0      // LHU UNSIGNED              goto Store_RD_WORD	0102:CF36 RJMP 0x0039            //       I_X1_XX0:            // SYSTEM also here !!                     // JALR ??            if not I0.6 then goto not_JALR0103:FF06 SBRS R16,60104:C04E RJMP 0x0153      //      if not I0.5 then goto not_JALR      I_11:            if     I0.4 then goto Do_SYS0105:FD04 SBRC R16,40106:C005 RJMP 0x010C            if     I0.3 then goto not_JALR0107:FD03 SBRC R16,30108:C04A RJMP 0x0153            if not I0.2 then goto not_JALR0109:FF02 SBRS R16,2010A:C048 RJMP 0x0153            goto I_IMMED010B:CF60 RJMP 0x006C            //      //      //      Do_SYS:            #file 5      #line 1      ////////////////////////////////////      	Z.hi  := CRH010C:EFF2 LDI R31,0xF2              Z.lo  := $10		 // mepc 	010D:E1E0 LDI R30,0x10      	TEMP  := 0;010E:E0C0 LDI R28,0x00      	      	// EBREAK/ECALL ?      	WREG := I1010F:2FF1 MOV R31,R17      	WREG := WREG and $700110:77F0 ANDI R31,0x70      	if WREG=0 then0111:23FF AND R31,R310112:F4A9 BRNE 0x0128      		if not I3.4 then SYS_xxx0_xxxx_xxxx0113:FF34 SBRS R19,40114:C003 RJMP 0x0118      SYS_xxxx_xxxx_xxxx: 		               		if I3.5 then do_exec  // MRET0115:FD35 SBRC R19,50116:C00E RJMP 0x0125      		// WFI      		TEMP := $800117:E8C0 LDI R28,0x80            		      SYS_xxx0_xxxx_xxxx:      // ECALL/EBREAK      		RAM[Z] := PC.lo	         // mepc0118:82A0 ST Z,R10      		RAM[Z+1] := PC.hi        // 0119:82B1 ST Z+1,R11            		WREG := $03		 // ECALL/EBREAK011A:E0F3 LDI R31,0x03      		if I2.4 then skip011B:FF24 SBRS R18,4      			or WREG, $08011C:60F8 ORI R31,0x08      		if temp=0 then skip011D:23CC AND R28,R28011E:F009 BREQ 0x0120      			wreg := 7	 // MTIMER intterrupt	011F:E0F7 LDI R31,0x07      		Z.lo   := $23;0120:E2E3 LDI R30,0x23      		RAM[Z] := TEMP;		 // Interrupt flag0121:83C0 ST Z,R28      go_mtvec_ecause:      	        Z.lo   := $20		 // mcause0122:E2E0 LDI R30,0x20      		RAM[Z] := WREG	         // 0123:83F0 ST Z,R31      go_mtvec:      	        Z.lo   := $50		 // mtvec0124:E5E0 LDI R30,0x50      do_exec:      		PC.lo  := RAM[Z]         // 0125:80A0 LD R10,Z       		PC.hi  := RAM[Z+1]         // 0126:80B1 LD R11,Z+1            		goto MainStart0127:CF2E RJMP 0x0056      	end       //////////////////////////////////////////////                  	Z.lo := I20128:2FE2 MOV R30,R18      	and Z.lo, $F00129:7FE0 ANDI R30,0xF0            //	if I3=$34 then            //	end            	if I3.7 then012A:FF37 SBRS R19,7012B:C001 RJMP 0x012D      	     Z.lo := Z.lo or $4012C:60E4 ORI R30,0x04      	end            	//      	// read CSR      	//      	RD0 := RAM[Z]; 012D:8140 LD R20,Z       	RD1 := RAM[Z+1];012E:8151 LD R21,Z+1      	RD2 := RAM[Z+2];012F:8162 LD R22,Z+2      	RD3 := RAM[Z+3]; 0130:8173 LD R23,Z+3      //      // CSR loaded      //      	if  not  I1.6 then goto csr_notimm0131:FF16 SBRS R17,60132:C009 RJMP 0x013C      // todo get 5 bit immed value      	RS1_0 := i2; 0133:2EC2 MOV R12,R18      	RS1_0 := RS1_0 and $0F; 0134:E0FF LDI R31,0x0F0135:22CF AND R12,R31      	add RS1_0, RS1_00136:0CCC ADD R12,R12      	if not I1.7 then skip; 0137:FD17 SBRC R17,7      	sub RS1_0,FF 0138:18C1 SUB R12,R1      	RS1_1 := 0;	0139:24DD EOR R13,R13      	RS1_2 := 0;013A:24EE EOR R14,R14      	RS1_3 := 0;013B:24FF EOR R15,R15      csr_notimm:      	if not I1.5 then goto CSR_WRITE013C:FF15 SBRS R17,5013D:C010 RJMP 0x014E      	if     I1.4 then goto Do_CSRRC013E:FD14 SBRC R17,4013F:C005 RJMP 0x0145      // Set Bits      	// Set Bits      	RS1_0 := RS1_0 or RD00140:2AC4 OR  R12,R20      	RS1_1 := RS1_1 or RD10141:2AD5 OR  R13,R21      	RS1_2 := RS1_2 or RD20142:2AE6 OR  R14,R22      	RS1_3 := RS1_3 or RD30143:2AF7 OR  R15,R23      	goto CSR_WRITE0144:C009 RJMP 0x014E      Do_CSRRC:      	WREG := $FF0145:EFFF LDI R31,0xFF      	RS1_0 := RS1_0 xor WREG	0146:26CF EOR R12,R31      	RS1_1 := RS1_1 xor WREG	0147:26DF EOR R13,R31      	RS1_2 := RS1_2 xor WREG	0148:26EF EOR R14,R31      	RS1_3 := RS1_3 xor WREG	0149:26FF EOR R15,R31            	RS1_0 := RS1_0 and RD0014A:22C4 AND R12,R20      	RS1_1 := RS1_1 and RD1014B:22D5 AND R13,R21      	RS1_2 := RS1_2 and RD2014C:22E6 AND R14,R22      	RS1_3 := RS1_3 and RD3014D:22F7 AND R15,R23      CSR_WRITE:      //      // Write back here      //       	// write CSR      	RAM[Z+3] := RS1_3; 014E:82F3 ST Z+3,R15      	RAM[Z+2] := RS1_2; 014F:82E2 ST Z+2,R14      	RAM[Z+1] := RS1_1; 0150:82D1 ST Z+1,R13      	RAM[Z] := RS1_00151:82C0 ST Z,R12      //////////////////////////////////            #file 1      #line 400            	goto Store_RD0152:CEE8 RJMP 0x003B            not_JALR:            //      if I0.6 then goto I_11_XX0 // branches      	if I0.6 then goto Load_RS2 // branches !0153:FD06 SBRC R16,60154:C012 RJMP 0x0167            // STORE      I_01_XX0:      // RS1 is loaded            	if I0.4 then goto Load_RS2; //STORE0155:FD04 SBRC R16,40156:C010 RJMP 0x0167      //      // RS1 is loaded      //      //I_01_1X0:            //	Goto Load_RS2            STORE:	        	RD0 := I10157:2F41 MOV R20,R17      	add RD0,RD00158:0F44 ADD R20,R20      	and RD0,$1E0159:714E ANDI R20,0x1E      	if not I0.7 then skip; RD0 := RD0 or $01;015A:FD07 SBRC R16,7015B:6041 ORI R20,0x01            	wreg := i3015C:2FF3 MOV R31,R19      	swap wreg015D:95F2 SWAP R31      	and wreg,$E0;015E:7EF0 ANDI R31,0xE0      	or RD0, wreg015F:2B4F OR  R20,R31            	RD1 := I3;0160:2F53 MOV R21,R19      	swap RD10161:9552 SWAP R21      	and RD1, $070162:7057 ANDI R21,0x07      	if not I3.7 then skip; RD1 := RD1 or $F8; // sign extend!0163:FD37 SBRC R19,70164:6F58 ORI R21,0xF8            	RS1_0 := RS1_0 + RD00165:0EC4 ADD R12,R20      	ADC RS1_1, RD10166:1ED5 ADC R13,R21            // Load RS2      Load_RS2:      //            // xxxx_xxx4 3210_xxxx xxxx_xxxx xxxx_xxxx      // x432 10xx      //        Z.lo := I2      //	lsr Z.lo      //	lsr Z.lo      //        if not I3.0 then skip; Z.lo := Z.lo or $40;      //	Z.lo := Z.lo and $7C                    Z.lo := I20167:2FE2 MOV R30,R18      	//lsr Z.lo      	lsr Z.lo0168:95E6 LSR R30              if not I3.0 then skip; Z.lo := Z.lo or $80;0169:FD30 SBRC R19,0016A:68E0 ORI R30,0x80      	Z.lo := Z.lo and $F8016B:7FE8 ANDI R30,0xF8            // Makes Dhrystone slower on single cycle RAM      //	if not FLAGS.1 then Load_RS2_RAM      //	RS2_0 := 0	      //	RS2_1 := 0	      //	RS2_2 := 0	      //	RS2_3 := 0	      //   	goto Load_RS2_Done            // TODO R0 ZERO !!      Load_RS2_RAM:      	Z.Hi := RRH; // Register save area016C:EFF1 LDI R31,0xF1      	RS2_0 := RAM[Z]; 016D:8180 LD R24,Z       	RS2_1 := RAM[Z+1];016E:8191 LD R25,Z+1      	RS2_2 := RAM[Z+2];016F:81A2 LD R26,Z+2      	RS2_3 := RAM[Z+3]; 0170:81B3 LD R27,Z+3      Load_RS2_Done:      // Branches?      //	if I0.6 then goto Do_Branch            	if not I0.6 then alustore0171:FF06 SBRS R16,60172:C02A RJMP 0x019D            // branches      Do_Branch:      //      // Check condition      //      // signed?	      	if I1.5 then goto UNSIG0173:FD15 SBRC R17,50174:C003 RJMP 0x0178      // signed trick      	wreg := $800175:E8F0 LDI R31,0x80      	xor RS1_3, wreg0176:26FF EOR R15,R31      	xor RS2_3, wreg0177:27BF EOR R27,R31      UNSIG:	      	SUB RS1_0, RS2_00178:1AC8 SUB R12,R24      	SBC RS1_1, RS2_10179:0AD9 SBC R13,R25      	SBC RS1_2, RS2_2017A:0AEA SBC R14,R26      	SBC RS1_3, RS2_3017B:0AFB SBC R15,R27      	      	if not I1.6 then goto BNE_BEQ017C:FF16 SBRS R17,6017D:C016 RJMP 0x0194      	if     I1.4 then goto is_BGE017E:FD14 SBRC R17,4017F:C002 RJMP 0x0182      // BLT      asm      	brcs Take_Branch0180:F010 BRCS 0x0183      end	      	goto MainLoop0181:CEC5 RJMP 0x0047            // BGEU      is_BGE:      asm      	brcs main_l1;   //brcc Take_Branch0182:F0B8 BRCS 0x019A      end	      //	goto MainLoop            Take_Branch:      	add i1,i10183:0F11 ADD R17,R17      	and i1, $1E // bits 4..10184:711E ANDI R17,0x1E      	swap i30185:9532 SWAP R19      	wreg := i30186:2FF3 MOV R31,R19      	and wreg, $E00187:7EF0 ANDI R31,0xE0      	or i1, wreg	// 7..10188:2B1F OR  R17,R31      	and i3,$0f0189:703F ANDI R19,0x0F      	if not i3.3 then skip018A:FD33 SBRC R19,3      	or i3,$10	// merge bit 12018B:6130 ORI R19,0x10      	and i3,$17018C:7137 ANDI R19,0x17      	if not i0.7 then skip018D:FD07 SBRC R16,7      	or i3,$08	// merge bit 11018E:6038 ORI R19,0x08      	if not i3.4 then skip018F:FD34 SBRC R19,4      	or i3,$E0	// sign extend 16 bit0190:6E30 ORI R19,0xE0      	add PC.lo, i10191:0EA1 ADD R10,R17      	adc PC.hi, i30192:1EB3 ADC R11,R19      	goto MainStart0193:CEC2 RJMP 0x0056            BNE_BEQ:      	or RS1_0, RS1_10194:28CD OR  R12,R13      	or RS1_0, RS1_20195:28CE OR  R12,R14      	or RS1_0, RS1_30196:28CF OR  R12,R15      	if not I1.4 then goto is_BEQ	0197:FF14 SBRS R17,40198:C002 RJMP 0x019B      // BNE      asm      	brne Take_Branch0199:F749 BRNE 0x0183      end	      main_l1:      	goto MainLoop019A:CEAC RJMP 0x0047            is_BEQ:      asm      	breq Take_Branch019B:F339 BREQ 0x0183      end	      	goto MainLoop019C:CEAA RJMP 0x0047                  // Store or ALU ?      alustore:      	if not I0.4 then goto Do_Store019D:FF04 SBRS R16,4019E:C011 RJMP 0x01B0            	RD0 := RS2_0019F:2F48 MOV R20,R24      	RD1 := RS2_101A0:2F59 MOV R21,R25      	RD2 := RS2_201A1:2F6A MOV R22,R26      	RD3 := RS2_301A2:2F7B MOV R23,R27      //      // check ALU       	if I1.6 then goto Do_XOR_AND // bit 1401A3:FD16 SBRC R17,601A4:CF06 RJMP 0x00AB      	if I1.5 then goto Do_SLT // bit 1301A5:FD15 SBRC R17,501A6:CF1D RJMP 0x00C4      	if I1.4 then goto Do_SLL // bit 1201A7:FD14 SBRC R17,401A8:CEF4 RJMP 0x009D            Do_AddSub:      	if not I3.6 then goto Do_ADDI	01A9:FF36 SBRS R19,601AA:CED8 RJMP 0x0083      // SUB OK              SUB RS1_0, RS2_001AB:1AC8 SUB R12,R24              SBC RS1_1, RS2_101AC:0AD9 SBC R13,R25              SBC RS1_2, RS2_201AD:0AEA SBC R14,R26              SBC RS1_3, RS2_301AE:0AFB SBC R15,R27            	goto Store_RS101AF:CEF6 RJMP 0x00A6                  Do_Store:      // store to RS1      	Z.Lo := RS1_001B0:2DEC MOV R30,R12      	Z.Hi := RS1_101B1:2DFD MOV R31,R13      //       	if I1.4 then goto I_SH_SW01B2:FD14 SBRC R17,401B3:C013 RJMP 0x01C7      	if I1.5 then goto I_SH_SW01B4:FD15 SBRC R17,501B5:C011 RJMP 0x01C7      // Store byte      I_SB:            	RAM[Z] := RS2_0; 01B6:8380 ST Z,R24      #file 6      #line 1      // HAABBB G@@AAA      //      // Transmit Only UART implementation      //      //	RAM[Z] := RS2_0;       	// stupid way to exclude CPI      //        WREG := Z.hi      //	WREG := WREG-$C0      //	if not FLAGS.1 then              if not Zhi.7 then not_uart01B7:FFF7 SBRS R31,701B8:C00D RJMP 0x01C6              if     Zhi.5 then not_uart01B9:FDF5 SBRC R31,501BA:C00B RJMP 0x01C6      	      		temp := 10; // number of bits	01BB:E0CA LDI R28,0x0A      		UART_TX = ZERO;	// Start bit01BC:B800 OUT UART_TX,R0      		repeat      			wreg := UART_BAUDCONST; 01BD:E4FD LDI R31,0x4D      			repeat       				ADD wreg,FF01BE:0DF1 ADD R31,R1      			until FLAGS.101BF:F7F1 BRNE 0x01BE      //			until --wreg; // Bit delay 115200 50MHz      			UART_TX = RS2_0; // transmit bit01C0:B980 OUT UART_TX,R24      			ROR RS2_0;01C1:9587 ROR R24      			OR RS2_0, $80	// insert STOP bit01C2:6880 ORI R24,0x80      			ADD temp,FF01C3:0DC1 ADD R28,R1      		until FLAGS.101C4:F7C1 BRNE 0x01BD      //		until --temp;      		Goto MainLoop01C5:CE81 RJMP 0x0047      //	end;      not_uart:            //      //      //                  #file 1      #line 585            	goto MainLoop01C6:CE80 RJMP 0x0047      //      I_SH_SW:      	if Zlo.0 then MISALIGN_ST01C7:FDE0 SBRC R30,001C8:CE68 RJMP 0x0031      	if I1.4 then goto ST_LOW1601C9:FD14 SBRC R17,401CA:C004 RJMP 0x01CF      I_SW:      	if Zlo.1 then MISALIGN_ST01CB:FDE1 SBRC R30,101CC:CE64 RJMP 0x0031      	RAM[Z+3] := RS2_3; 01CD:83B3 ST Z+3,R27      	RAM[Z+2] := RS2_2; 01CE:83A2 ST Z+2,R26      ST_LOW16:      	RAM[Z] := RS2_0; 01CF:8380 ST Z,R24      	RAM[Z+1] := RS2_1; 01D0:8391 ST Z+1,R25      	goto MainLoop01D1:CE75 RJMP 0x0047            //      //      // LUI/AUIPC/JAL/JALR/FENCE      I_XX_XX1:             if I0.4 then goto I_XX_1X1  // -> AUIPC/LUI01D2:FD04 SBRC R16,401D3:C01D RJMP 0x01F1      // JAL/JALR/FENCE      I_XX_0X1:      	if not I0.5 then goto MainLoop // -> FENCE01D4:FF05 SBRS R16,501D5:CE71 RJMP 0x0047      I_X1_0X1:      // JAL/JALR      	if not I0.3 then goto LD_rs1  // JALR >>01D6:FF03 SBRS R16,301D7:CE88 RJMP 0x0060      // JAL            	swap I301D8:9532 SWAP R19      	AND I3, $F701D9:7F37 ANDI R19,0xF7      	if not I2.4 then skip01DA:FD24 SBRC R18,4      	OR I3, $08 // 7654 11 10 9 801DB:6038 ORI R19,0x08      	swap I201DC:9522 SWAP R18      	AND I2,$0E // xxxx 3 2 1 _01DD:702E ANDI R18,0x0E      	RS1_0 := I301DE:2EC3 MOV R12,R19      	RS1_0 := RS1_0 and $F001DF:EFF0 LDI R31,0xF001E0:22CF AND R12,R31      	RS1_0 := RS1_0 or I2 // 7..1 x01E1:2AC2 OR  R12,R18      	RS1_1 := I101E2:2ED1 MOV R13,R17      	RS1_1 := RS1_1 and $F0 // 15..1201E3:22DF AND R13,R31      	I3 := I3 and $0F01E4:703F ANDI R19,0x0F      	RS1_1 := RS1_1 or I301E5:2AD3 OR  R13,R19      	//       Store_RET:      	PC.lo := PC.lo+4	01E6:E0F4 LDI R31,0x0401E7:0EAF ADD R10,R31      	ADC PC.hi, ZERO01E8:1CB0 ADC R11,R0      		RD0 := PC.lo01E9:2D4A MOV R20,R10      		RD1 := PC.hi01EA:2D5B MOV R21,R11      	ADD PC.lo, RS1_001EB:0CAC ADD R10,R12      	ADC PC.hi, RS1_101EC:1CBD ADC R11,R13      		WREG := 801ED:E0F8 LDI R31,0x08      		SUB PC.lo, WREG01EE:1AAF SUB R10,R31      		SBC PC.hi, ZERO01EF:08B0 SBC R11,R0      	goto Store_RD_WORD01F0:CE48 RJMP 0x0039            // AUIPC/LUI      I_XX_1X1:      	// Load IMMED, clear lower bits      	RD3 := I3; // copy bits 31..24	01F1:2F73 MOV R23,R19      	RD2 := I2; // copy bits 23..1601F2:2F62 MOV R22,R18      	RD1 := I1; // copy bits 15..801F3:2F51 MOV R21,R17      	RD1 := RD1 and $F0; // clear bits 11..801F4:7F50 ANDI R21,0xF0      	RD0 := 0;  // clear bits 7..001F5:E040 LDI R20,0x00              if I0.5 then goto Store_RD01F6:FD05 SBRC R16,501F7:CE43 RJMP 0x003B            // AUIPC            	RD0 := PC.lo;01F8:2D4A MOV R20,R10      	RD1 := RD1 + PC.hi01F9:0D5B ADD R21,R11      	goto Store_RD01FA:CE40 RJMP 0x003B      //      //      //                  	until false;01FB:CE4B RJMP 0x0047      //      //      //                                                * SYMBOL TABLE ** LABELS *REPEAT@01                         000A  0REPEAT@01@CONT                    000F  0REPEAT@01@BREAK                   0011  0BOOTLOOP                          0017  0REPEAT@02                         0018  0REPEAT@02@CONT                    0022  0REPEAT@02@BREAK                   0024  0MISALIGN_LD                       002F  0MISALIGN_ST                       0031  0MISALING_LDST                     0032  0STORE_0                           0037  0STORE_RD_BYTE                     0038  0STORE_RD_WORD                     0039  0STORE_RD                          003B  0REPEAT@03                         0047  0MAINLOOP                          0047  0MTVEC_MTVAL                       004B  0MTVEC_MEPC                        004F  0MTVEC_ECAUSE                      0052  0NEXTPC                            0053  0MAINSTART                         0056  0LD_RS1                            0060  0I_0X_XX0                          006C  0I_XX_XX0                          006C  0I_IMMED                           006C  0IMM12_P                           007B  0DO_ADDI                           0083  0LOGIC                             0088  0DO_XOR                            008C  0OR_AND                            0091  0DO_OR                             0093  0DO_AND                            0098  0DO_SLL                            009D  0DO_SLLI                           009E  0REPEAT@04                         00A0  0REPEAT@04@CONT                    00A5  0REPEAT@04@BREAK                   00A6  0STORE_RS1                         00A6  0DO_XOR_AND                        00AB  0DO_SR                             00B2  0REPEAT@05                         00B6  0REPEAT@05@CONT                    00BB  0REPEAT@05@BREAK                   00BC  0DO_SRLI                           00BD  0REPEAT@06                         00BD  0REPEAT@06@CONT                    00C2  0REPEAT@06@BREAK                   00C3  0DO_SLT                            00C4  0DO_SLTIU                          00C9  0STORE_1                           00CF  0I_00_0X1                          00D1  0DO_LOADS                          00E2  0I_LH                              00F0  0I_LD_W                            00F5  0I_LD_H                            00FD  0I_X1_XX0                          0103  0I_11                              0105  0DO_SYS                            010C  0SYS_XXXX_XXXX_XXXX                0115  0SYS_XXX0_XXXX_XXXX                0118  0GO_MTVEC_ECAUSE                   0122  0GO_MTVEC                          0124  0DO_EXEC                           0125  0IF@001@ELSE                       0128  0IF@001@END                        0128  0IF@002@ELSE                       012D  0IF@002@END                        012D  0CSR_NOTIMM                        013C  0DO_CSRRC                          0145  0CSR_WRITE                         014E  0NOT_JALR                          0153  0I_01_XX0                          0155  0STORE                             0157  0LOAD_RS2                          0167  0LOAD_RS2_RAM                      016C  0LOAD_RS2_DONE                     0171  0DO_BRANCH                         0173  0UNSIG                             0178  0IS_BGE                            0182  0TAKE_BRANCH                       0183  0BNE_BEQ                           0194  0MAIN_L1                           019A  0IS_BEQ                            019B  0ALUSTORE                          019D  0DO_ADDSUB                         01A9  0DO_STORE                          01B0  0I_SB                              01B6  0REPEAT@07                         01BD  0REPEAT@08                         01BE  0REPEAT@08@CONT                    01BF  0REPEAT@08@BREAK                   01C0  0REPEAT@07@CONT                    01C4  0REPEAT@07@BREAK                   01C5  0NOT_UART                          01C6  0I_SH_SW                           01C7  0I_SW                              01CB  0ST_LOW16                          01CF  0I_XX_XX1                          01D2  0I_XX_0X1                          01D4  0I_X1_0X1                          01D6  0STORE_RET                         01E6  0I_XX_1X1                          01F1  0REPEAT@03@CONT                    01FB  0REPEAT@03@BREAK                   01FC  0Program Memory used : 508 wordsInternal EEPROM used: 0 bytesErrors: 0